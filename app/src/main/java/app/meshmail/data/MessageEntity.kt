package app.meshmail.data

import androidx.room.*
import java.util.*
// @Entity(indices = {@Index(value = {"first_name"},unique = true)})
@Entity(tableName = "messages")
data class MessageEntity(

    // not particularly important because the same message on a relay and a client
    // could have different database IDs if they were transferred out of order
    @PrimaryKey(autoGenerate = true) var id: Int? = null,

    // this is the long id generated by a mail server typically <UUID>@domain
    var serverId: String? = "",

    // message subject
    var subject: String? = "",

    // body
    var body: String? = "",

    // aka to
    var recipient: String? = "",

    // aka from
    var sender: String? = "",

    // duh
    var receivedDate: Date? = null,

    // a shadow message is a teaser, or a partial message; true until data fields fully populated
    var isShadow: Boolean = true,

    // has a client requested any fragment of this message yet? if not, we need to broadcast
    // a message shadow object to alert clients.
    var hasBeenRequested: Boolean = false,

    // origin is either "INBOUND" meaning it came from imap/pop, was created on relay device first, syncd to
    // client device second. Or "OUTBOUND" meaning it originated on client, was sync'd to relay and sent
    var type: String = "INBOUND",

    // whether or not an outbound message has been sent over SMTP successfully via the relay.
    var hasBeenSent: Boolean = false,

    // perhaps a shorter version of serverID, but deterministic. e.g. last 8 bytes of md5
    // mostly to save space & not have to send across full serverID. Maybe MD5 of the concatenated protobuf
    // TODO: enforce a unique constraint here
    var fingerprint: String = "",

    var nFragments: Int? = null,

    var protoBufSize: Int? = null,
)
